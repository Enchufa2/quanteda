---
title: "The external pointer-based tokens object"
author: Kohei Watanabe
output:  
  html_document:
    toc: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "##"
)
```

In **quanteda** v4.0, we introduced a new type of tokens object, `tokens_xptr`, to make the efficiency of operations on a large corpus. Its `tokens` object has been a list of vectors that record integer IDs of token. Every time, `tokens_*` functions are applied, a tokens object is converted to a C++ object, modified and converted back to R. As the corpus become larger, the conversion of tokens between R and C++ becomes very expensive, taking much of the execution time. However, the `tokens_xptr` object is based on a external-pointer object that keeps the data as the C++ object, making the cost of conversion close to zero. This is beneficial especially for users who preprocess large tokens objects through a long pipeline. 

## Creating tokens_xptr object

You can create a `tokens_xptr` from `tokens` using `as.tokens_xptr()`. If `xtoks` is printed, the address of its underlying data is shown in the first line. As an external pointer object, the underlying data of the copy of the object `xtoks_copy` is the same. This means operations on `xtoks` uisng `tokens_*` functions also affect `xtoks_copy` even after the copying (shallow copy). If you want to copy the underlying data (deep copy), `as.tokens_xptr()` should be applied again.

```{r, echo=FALSE, include=FALSE}
#data_corpus_guardian <- readRDS('/home/kohei/Dropbox/Public/data_corpus_guardian2016.rds') 
data_corpus_guardian <- readRDS('C:/Users/watan/Dropbox/Public/data_corpus_guardian2016.rds')
```

```{r}
require(quanteda)

corp <- corpus_reshape(data_corpus_guardian)

toks <- tokens(corp)
xtoks <- as.tokens_xptr(toks)
print(xtoks, max_ndoc = 1)

## shallow copy
xtoks_copy <- xtoks
print(xtoks_copy, max_ndoc = 1)

## deep copy 
xtoks_deepcopy <- as.tokens_xptr(xtoks)
print(xtoks_deepcopy, max_ndoc = 1)
```

## Saving tokens_xptr objects

You should also note that you cannot save the underlying data of `tokens_xptr` objects. Thus, you should apply `as.tokens(xtoks)` before passing it to `save()` or `saveRDS()`.

```{r, eval=FALSE}
saveRDS(as.tokens(xtoks), file = "tokens_guardian.rds")
```

## Benchmarking

We apply the same `tokens_*` functions to `tokens` and `tokens_xptr` objects and construct a dfm in this mock pipeline. The execution time of the pipeline for the latter is significantly shorter due to the cost saved by passing the data without expensive conversion from one function to another.

```{r}
microbenchmark::microbenchmark(
    tokens = toks %>% 
        tokens_remove(stopwords("en"), padding = TRUE) %>% 
        tokens_remove(c("http:*", "https:*", "*.com", "*.org", "*.net"), padding = TRUE) %>% 
        tokens_compound(newsmap::data_dictionary_newsmap_en) %>% 
        dfm(remove_padding = TRUE),
    tokens_xptr = as.tokens_xptr(toks) %>% 
        tokens_remove(stopwords("en"), padding = TRUE) %>% 
        tokens_remove(c("http:*", "https:*", "*.com", "*.org", "*.net"), padding = TRUE) %>% 
        tokens_compound(newsmap::data_dictionary_newsmap_en) %>% 
        dfm(remove_padding = TRUE),
    times = 10
)
```

