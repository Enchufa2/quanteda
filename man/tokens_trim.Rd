% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tokens_trim.R
\name{tokens_trim}
\alias{tokens_trim}
\title{Trim a tokens using frequency threshold-based feature selection}
\usage{
tokens_trim(
  x,
  min_termfreq = NULL,
  max_termfreq = NULL,
  termfreq_type = c("count", "prop", "rank", "quantile"),
  min_docfreq = NULL,
  max_docfreq = NULL,
  docfreq_type = c("count", "prop", "rank", "quantile"),
  padding = FALSE,
  verbose = quanteda_options("verbose")
)
}
\arguments{
\item{x}{a \link{dfm} object}

\item{min_termfreq, max_termfreq}{minimum/maximum values of feature frequencies
across all documents, below/above which features will
be removed}

\item{termfreq_type}{how \code{min_termfreq} and \code{max_termfreq} are
interpreted.  \code{"count"} sums the frequencies; \code{"prop"} divides the
term frequencies by the total sum; \code{"rank"} is matched against the
inverted ranking of features in terms of overall frequency, so that 1, 2,
... are the highest and second highest frequency features, and so on;
\code{"quantile"} sets the cutoffs according to the quantiles (see
\code{\link[=quantile]{quantile()}}) of term frequencies.}

\item{min_docfreq, max_docfreq}{minimum/maximum values of a feature's document
frequency, below/above which features will be removed}

\item{docfreq_type}{specify how \code{min_docfreq} and \code{max_docfreq} are
interpreted.   \code{"count"} is the same as \verb{[docfreq](x, scheme = "count")}; \code{"prop"} divides the document frequencies by the total
sum; \code{"rank"} is matched against the inverted ranking of document
frequency, so that 1, 2, ... are the features with the highest and second
highest document frequencies, and so on; \code{"quantile"} sets the cutoffs
according to the quantiles (see \code{\link[=quantile]{quantile()}}) of document
frequencies.}

\item{verbose}{print messages}
}
\value{
A \link{tokens} object with reduced size.
}
\description{
Returns a tokens object reduced in size based on
document and term frequency, usually in terms of a minimum frequency, but
may also be in terms of maximum frequencies.  Setting a combination of
minimum and maximum frequencies will select features based on a range.
}
\examples{
dfmat <- dfm(tokens(data_corpus_inaugural))

# keep only words occurring >= 10 times and in >= 2 documents
dfm_trim(dfmat, min_termfreq = 10, min_docfreq = 2)

# keep only words occurring >= 10 times and in at least 0.4 of the documents
dfm_trim(dfmat, min_termfreq = 10, min_docfreq = 0.4)

# keep only words occurring <= 10 times and in <=2 documents
dfm_trim(dfmat, max_termfreq = 10, max_docfreq = 2)

# keep only words occurring <= 10 times and in at most 3/4 of the documents
dfm_trim(dfmat, max_termfreq = 10, max_docfreq = 0.75)

# keep only words occurring 5 times in 1000, and in 2 of 5 of documents
dfm_trim(dfmat, min_docfreq = 0.4, min_termfreq = 0.005, termfreq_type = "prop")

## quantiles
toks <- as.tokens(list(unlist(mapply(rep, letters[1:10], 10:1), use.names = FALSE)))
dfmat <- dfm(toks)
dfmat

# keep only the top 20th percentile or higher features

# keep only words above the 80th percentile
dfm_trim(dfmat, min_termfreq = 0.800001, termfreq_type = "quantile", verbose = TRUE)

# keep only words occurring frequently (top 20\%) and in <=2 documents
dfm_trim(dfmat, min_termfreq = 0.2, max_docfreq = 2, termfreq_type = "quantile")


}
\seealso{
\code{\link[=dfm_trim]{dfm_trim()}}
}
